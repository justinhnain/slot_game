---
title: "Summoned Plunderer"
format: html
editor: visual
---

```{r}
#| output: false
{
  library(tidyverse)  #useful dataframe functions for R
  library(infer)      #statistical inference libraries
  library(reticulate) #allows Python and R interoperability
}
```

```{python}
import random, itertools
```

# Define a 3-reel 1-line game

```{python}

#elements that reels 1 to 3 can assume
N1 = 10
N2 = 11
N3 = 5

#reels 1 to 3
x1 = list(range(1,N1 + 1))
x2 = list(range(1,N2 + 1))
x3 = list(range(1,N3 + 1))

num_combinations = N1*N2*N3
combinations= list(itertools.product(x1, x2, x3))
```

We define the set of all outcomes to be a combination of ordered triples to be$\Omega$, equal to the set of all $(x_1, x_2, x_3) \in \{x,y,z \in \mathbb{N}^3 : 1 \leq x \leq 10, 1 \leq y \leq 11, 1 \leq z \leq 5\}$\

### Include a bonus round for when the second reel is "11"

In other words, if $x_2 = 11$ leads to the payout being an outcome of the discrete random variable $X$ with the following payout table:

```{python}
#| echo: false

from IPython.display import Markdown
from tabulate import tabulate
table = [
         ["p(x)","1/6","1/6","1/6","1/6","1/6","1/6"],
         ["f(x)",15, 15, 15, 15, 30, 30],
         ]
Markdown(tabulate(
  table, 
  headers=["X", "1", "2", "3", "4", "5", "6"]
))

```

For which $E[x] = 20$.

```{python}
#expected value must be $20

lower_wins = [1, 2, 3, 4]
upper_wins = [5, 6]

lower_payout = 15
upper_payout = 30

def bonus_roll():
  roll = random.randint(1,6)
  if (roll in lower_wins):
    return lower_payout
  else:
    return upper_payout

```

### Define the payout matrix and winning combos

We define the set of winning combinations $W \subset \Omega$ to be equal to $\{(x,y,z) \in \Omega: y = 11 \lor (x,y) \in \{(5,5), (1,1), (2,2)\}\lor x=y=z\}$ and the payout function $$f: W \rightarrow \mathbb{R}$$ such that

$$
f(w) = 
\begin{cases}
  1, & \text{if } w = (5,5,x_3) \\
  1, & \text{if } w = (2,2,x_3) \\
1, & \text{if } w = (1,1,x_3) \\
3, & \text{if } w\text{'s coordinates are all equal}  \\
X, & \text{if } w = (x_1, 11, x_3)
\end{cases}
$$

```{python}
#| output: false


#winning combos & payouts
wins = {
  # (5, 5) : 1,
  # (1, 1) : 1,
  # (2, 2) : 1
  # (x odd, 11, y) : bonus_roll() with expected payout 20,
  # (x, y, z) : 3 when x = y = z
}


centre_11_win = list(filter((lambda combo : combo[1] == 11 and combo[0] % 2 == 1), combinations))
all_equal_win = list(filter(lambda combo: combo[0] == combo[1] == combo[2], combinations))

def leading_double(num, combo):
  return num == combo[0] == combo[1] != combo[2] #exclude triples
  
manual_5_wins = list(filter(lambda combo : leading_double(5, combo), combinations))
manual_2_wins = list(filter(lambda combo : leading_double(2, combo), combinations))
manual_1_wins = list(filter(lambda combo : leading_double(1, combo), combinations))

```

### Build the payout matrix

In other words, we populate $f$, where $f$ is defined by "wins".

```{python}
#| output: false

#add payout combos to win dictionary
[wins.update({win: bonus_roll}) for win in centre_11_win]
[wins.update({win: 3}) for win in all_equal_win] #add payouts for x = y = z case
[wins.update({win: 1}) for win in manual_5_wins]
[wins.update({win: 1}) for win in manual_2_wins]
[wins.update({win: 1}) for win in manual_1_wins]


```

### Test, test, test!

More rigorous testing ought to be done, but this captures some potential high level errors.

```{python}

#tests
assert num_combinations == len(combinations), "the number of combinations is incorrect"
assert len(centre_11_win) == N1 / 2 * N3, "the number of bonus rounds is incorrect"
assert len(all_equal_win) == min(N1, N2, N3), "the number of equal rounds is incorrect"
assert len(manual_5_wins) == 4, "the number of (5, 5, x) tuples is incorrect"
assert len(manual_2_wins) == 4, "the number of (2, 2, x) tuples is incorrect"
assert len(manual_1_wins) == 4, "the number of (1, 1, x) tuples is incorrect"

assert len(wins) == len(centre_11_win) + len(all_equal_win) + len(manual_5_wins) + len(manual_2_wins) + len(manual_1_wins), "number of winning combos is incorrect"

assert lower_payout * (len(lower_wins) / len(lower_wins + upper_wins)) + upper_payout * len(upper_wins) / len(lower_wins + upper_wins) == 20, "bonus roll expected payout isn't $20"


total_payout = 0
for i in all_equal_win + manual_5_wins + manual_2_wins + manual_1_wins:
  total_payout += wins[i]
for k in centre_11_win:
  total_payout += 20 #expected value of bonus rounds
  
expected_value = total_payout / num_combinations

assert expected_value < 1, f"your payout of {expected_value} favours the player!"
print(expected_value)
```

# Simulate a 3-reel 1-line game
